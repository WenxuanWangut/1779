name: cd
on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  id-token: write

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: true

env:
  IMAGE_BACKEND: ghcr.io/${{ github.repository_owner }}/app-backend
  IMAGE_FRONTEND: ghcr.io/${{ github.repository_owner }}/app-frontend

jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          filters: |
            backend:
              - 'app_backend/**'
              - '.github/workflows/**'
              - 'k8s/**'
            frontend:
              - 'frontend/**'
              - '.github/workflows/**'
              - 'k8s/**'

  build-push-backend:
    needs: detect
    if: needs.detect.outputs.backend == 'true'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: app_backend
    outputs:
      digest: ${{ steps.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_BACKEND }}
          tags: |
            type=sha
            type=raw,value=latest,enable=true
      - id: build
        uses: docker/build-push-action@v6
        with:
          context: app_backend/
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  build-push-frontend:
    needs: detect
    if: needs.detect.outputs.frontend == 'true'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: frontend
    outputs:
      digest: ${{ steps.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_FRONTEND }}
          tags: |
            type=sha
            type=raw,value=latest,enable=true
      - id: build
        uses: docker/build-push-action@v6
        with:
          context: frontend
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VITE_API_BASE=/api

  deploy:
    if: ${{ always() }}
    needs: [build-push-backend, build-push-frontend, detect]
    runs-on: ubuntu-latest
    env:
      DO_TOKEN: ${{ secrets.DO_TOKEN }}
      DO_K8S_CLUSTER: ${{ secrets.DO_K8S_CLUSTER }}
      KUBE_CONTEXT: ${{ secrets.KUBE_CONTEXT }}
      KUBE_NAMESPACE: ${{ secrets.KUBE_NAMESPACE }}
    steps:
      - uses: actions/checkout@v4

      - uses: azure/setup-kubectl@v4
        with:
          version: v1.30.0

      - name: Setup doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ env.DO_TOKEN }}

      - name: Fetch kubeconfig from DigitalOcean
        run: doctl kubernetes cluster kubeconfig save --expiry-seconds 900 "$DO_K8S_CLUSTER"

      - name: Use context
        if: ${{ env.KUBE_CONTEXT != '' }}
        run: kubectl config use-context "${KUBE_CONTEXT}"

      - name: Ensure namespace exists
        run: |
          NS="${KUBE_NAMESPACE}"
          if [ -z "$NS" ]; then NS=cloudcollab; fi
          echo "KUBE_NS=$NS" >> $GITHUB_ENV
          kubectl get ns "$NS" >/dev/null 2>&1 || kubectl create ns "$NS"

      - name: Apply base manifests
        run: |
          kubectl -n "$KUBE_NS" apply -k k8s/overlays/prod

      - name: Enforce backend single replica
        run: |
          kubectl -n "$KUBE_NS" scale deploy/app-backend --replicas=1 || true

      - name: Set images by digest
        run: |
          if [ "${{ needs.detect.outputs.backend }}" = "true" ]; then
            kubectl -n "$KUBE_NS" set image deploy/app-backend app-backend=${IMAGE_BACKEND}@${{ needs.build-push-backend.outputs.digest }} --record=true
          fi
          if [ "${{ needs.detect.outputs.frontend }}" = "true" ]; then
            kubectl -n "$KUBE_NS" set image deploy/app-frontend app-frontend=${IMAGE_FRONTEND}@${{ needs.build-push-frontend.outputs.digest }} --record=true
          fi

      - name: Patch services to LoadBalancer
        run: |
          kubectl -n "$KUBE_NS" patch svc app-frontend -p '{"spec":{"type":"LoadBalancer"}}' || true
          kubectl -n "$KUBE_NS" patch svc app-backend -p '{"spec":{"type":"LoadBalancer"}}' || true

      - name: Rollout status
        run: |
          kubectl -n "$KUBE_NS" rollout status deploy/app-backend --timeout=300s
          kubectl -n "$KUBE_NS" rollout status deploy/app-frontend --timeout=300s

      - name: Wait for External IPs and print URLs
        id: svc
        run: |
          set -e
          NS="$KUBE_NS"
          for i in $(seq 1 60); do
            FIP=$(kubectl -n "$NS" get svc app-frontend -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
            [ -n "$FIP" ] && break || sleep 5
          done
          for i in $(seq 1 60); do
            BIP=$(kubectl -n "$NS" get svc app-backend -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
            [ -n "$BIP" ] && break || sleep 5
          done
          echo "FRONTEND_IP=$FIP" >> $GITHUB_OUTPUT
          echo "BACKEND_IP=$BIP" >> $GITHUB_OUTPUT
          echo "Frontend: http://$FIP/"
          echo "Backend:  http://$BIP:8000/"

      - name: Smoke check (frontend)
        if: ${{ steps.svc.outputs.FRONTEND_IP != '' }}
        run: curl -fsS "http://${{ steps.svc.outputs.FRONTEND_IP }}/" | head -c 200 || true